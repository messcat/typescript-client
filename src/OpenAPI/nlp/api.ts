const BASE_PATH = "https://api.messcat.ai/nlp".replace(/\/+$/, "");

/* tslint:disable */
/* eslint-disable */
/**
 * NLP Service
 * AI automation
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
import type { RequestArgs } from '../base';
// @ts-ignore
import { COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from '../base';

/**
 * 
 * @export
 * @interface AddSourceFile
 */
export interface AddSourceFile {
    /**
     * 
     * @type {string}
     * @memberof AddSourceFile
     */
    'type': AddSourceFileTypeEnum;
    /**
     * URL of the file to add
     * @type {string}
     * @memberof AddSourceFile
     */
    'url': string;
}

export const AddSourceFileTypeEnum = {
    File: 'file'
} as const;

export type AddSourceFileTypeEnum = typeof AddSourceFileTypeEnum[keyof typeof AddSourceFileTypeEnum];

/**
 * Add a link to the knowledge base. Scrapes the link for content
 * @export
 * @interface AddSourceLink
 */
export interface AddSourceLink {
    /**
     * 
     * @type {string}
     * @memberof AddSourceLink
     */
    'type': AddSourceLinkTypeEnum;
    /**
     * URL of the link to add
     * @type {string}
     * @memberof AddSourceLink
     */
    'url': string;
    /**
     * Maximum depth to scrape the link
     * @type {number}
     * @memberof AddSourceLink
     */
    'maxDepth'?: number;
    /**
     * List of patterns to match links against. If empty, all links will be crawled.
     * @type {Array<string>}
     * @memberof AddSourceLink
     */
    'patterns'?: Array<string>;
    /**
     * Interval in hours to refetch the link
     * @type {number}
     * @memberof AddSourceLink
     */
    'refetchIntervalHours'?: number;
    /**
     * List of links that should not be crawled
     * @type {Array<string>}
     * @memberof AddSourceLink
     */
    'blockedLinks'?: Array<string>;
}

export const AddSourceLinkTypeEnum = {
    Link: 'link'
} as const;

export type AddSourceLinkTypeEnum = typeof AddSourceLinkTypeEnum[keyof typeof AddSourceLinkTypeEnum];

/**
 * @type AddSourceRequest
 * @export
 */
export type AddSourceRequest = AddSourceFile | AddSourceLink;

/**
 * 
 * @export
 * @interface AiCreditUse
 */
interface AiCreditUse {
    /**
     * 
     * @type {string}
     * @memberof AiCreditUse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AiCreditUse
     */
    'teamId': string;
    /**
     * 
     * @type {string}
     * @memberof AiCreditUse
     */
    'doneBy': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof AiCreditUse
     */
    'doneAt': string;
    /**
     * 
     * @type {AiCreditUseTranscriptionMetadata}
     * @memberof AiCreditUse
     */
    'transcriptionMetadata'?: AiCreditUseTranscriptionMetadata;
    /**
     * 
     * @type {AiCreditUseMetadata}
     * @memberof AiCreditUse
     */
    'metadata'?: AiCreditUseMetadata;
}
/**
 * 
 * @export
 * @interface AiCreditUseMetadata
 */
export interface AiCreditUseMetadata {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof AiCreditUseMetadata
     */
    'uniqueMessageId'?: string;
}
/**
 * 
 * @export
 * @interface AiCreditUseTranscriptionMetadata
 */
export interface AiCreditUseTranscriptionMetadata {
    /**
     * Duration of the transcription in seconds
     * @type {number}
     * @memberof AiCreditUseTranscriptionMetadata
     */
    'durationS': number;
}
/**
 * 
 * @export
 * @interface AutocompleteInbox200Response
 */
export interface AutocompleteInbox200Response {
    /**
     * Name of the chatbot that generated the suggestions. Will use \"AI\" if used vanilla GPT
     * @type {string}
     * @memberof AutocompleteInbox200Response
     */
    'chatbotName': string;
    /**
     * ID of the chatbot that generated the suggestions. Empty if used vanilla GPT
     * @type {string}
     * @memberof AutocompleteInbox200Response
     */
    'chatbotId'?: string;
    /**
     * 
     * @type {Array<AutocompleteSuggestion>}
     * @memberof AutocompleteInbox200Response
     */
    'suggestions': Array<AutocompleteSuggestion>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AutocompleteInbox200Response
     */
    'sources'?: Array<string>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AutocompleteModifier = {
    Longer: 'longer',
    Shorter: 'shorter',
    Formal: 'formal',
    Friendlier: 'friendlier',
    Apologetic: 'apologetic',
    Assertive: 'assertive',
    Clearer: 'clearer',
    Ask: 'ask'
} as const;

export type AutocompleteModifier = typeof AutocompleteModifier[keyof typeof AutocompleteModifier];


/**
 * 
 * @export
 * @interface AutocompleteModify200Response
 */
export interface AutocompleteModify200Response {
    /**
     * Modified text
     * @type {string}
     * @memberof AutocompleteModify200Response
     */
    'text': string;
}
/**
 * 
 * @export
 * @interface AutocompleteModifyRequest
 */
export interface AutocompleteModifyRequest {
    /**
     * 
     * @type {AutocompleteModifyRequestChat}
     * @memberof AutocompleteModifyRequest
     */
    'chat'?: AutocompleteModifyRequestChat;
    /**
     * Text to be modified
     * @type {string}
     * @memberof AutocompleteModifyRequest
     */
    'text': string;
    /**
     * Language to get response in
     * @type {string}
     * @memberof AutocompleteModifyRequest
     */
    'language'?: string;
}
/**
 * Provide chat as context for the modifier
 * @export
 * @interface AutocompleteModifyRequestChat
 */
export interface AutocompleteModifyRequestChat {
    /**
     * 
     * @type {string}
     * @memberof AutocompleteModifyRequestChat
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof AutocompleteModifyRequestChat
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface AutocompleteSuggestion
 */
export interface AutocompleteSuggestion {
    /**
     * 
     * @type {string}
     * @memberof AutocompleteSuggestion
     */
    'text': string;
}
/**
 * 
 * @export
 * @interface CrawlState
 */
export interface CrawlState {
    /**
     * Status of the crawl
     * @type {string}
     * @memberof CrawlState
     */
    'status': CrawlStateStatusEnum;
    /**
     * Error message if the crawl failed
     * @type {string}
     * @memberof CrawlState
     */
    'error'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof CrawlState
     */
    'updatedAt': string;
    /**
     * 
     * @type {number}
     * @memberof CrawlState
     */
    'links'?: number;
}

export const CrawlStateStatusEnum = {
    Pending: 'pending',
    InProgress: 'in-progress',
    Completed: 'completed',
    Failed: 'failed'
} as const;

export type CrawlStateStatusEnum = typeof CrawlStateStatusEnum[keyof typeof CrawlStateStatusEnum];

/**
 * Converse via a custom messages
 * @export
 * @interface CustomLlmChatInput
 */
export interface CustomLlmChatInput {
    /**
     * 
     * @type {string}
     * @memberof CustomLlmChatInput
     */
    'type': CustomLlmChatInputTypeEnum;
    /**
     * 
     * @type {Array<LlmMessage>}
     * @memberof CustomLlmChatInput
     */
    'messages': Array<LlmMessage>;
}

export const CustomLlmChatInputTypeEnum = {
    Messages: 'messages'
} as const;

export type CustomLlmChatInputTypeEnum = typeof CustomLlmChatInputTypeEnum[keyof typeof CustomLlmChatInputTypeEnum];

/**
 * 
 * @export
 * @interface GetCrawledLinks200Response
 */
export interface GetCrawledLinks200Response {
    /**
     * 
     * @type {Array<KnowledgeBaseSourceDataCrawledLink>}
     * @memberof GetCrawledLinks200Response
     */
    'items': Array<KnowledgeBaseSourceDataCrawledLink>;
}
/**
 * 
 * @export
 * @interface GetKnowledgeBases200Response
 */
export interface GetKnowledgeBases200Response {
    /**
     * 
     * @type {Array<KnowledgeBase>}
     * @memberof GetKnowledgeBases200Response
     */
    'items': Array<KnowledgeBase>;
}
/**
 * 
 * @export
 * @interface GetSources200Response
 */
export interface GetSources200Response {
    /**
     * 
     * @type {Array<KnowledgeBaseSource>}
     * @memberof GetSources200Response
     */
    'items': Array<KnowledgeBaseSource>;
}
/**
 * Converse via an existing IM chat. The unique identifier for the thread is simply `accountId/id`
 * @export
 * @interface ImLlmChatInput
 */
export interface ImLlmChatInput {
    /**
     * 
     * @type {string}
     * @memberof ImLlmChatInput
     */
    'type': ImLlmChatInputTypeEnum;
    /**
     * Account ID of the chat
     * @type {string}
     * @memberof ImLlmChatInput
     */
    'accountId': string;
    /**
     * ID of the chat
     * @type {string}
     * @memberof ImLlmChatInput
     */
    'id': string;
    /**
     * If no conversation exists with the bot, instructions to start the conversation
     * @type {string}
     * @memberof ImLlmChatInput
     */
    'instructions'?: string;
}

export const ImLlmChatInputTypeEnum = {
    ImChat: 'im-chat'
} as const;

export type ImLlmChatInputTypeEnum = typeof ImLlmChatInputTypeEnum[keyof typeof ImLlmChatInputTypeEnum];

/**
 * 
 * @export
 * @interface KnowledgeBase
 */
export interface KnowledgeBase {
    /**
     * ID of the knowledge base
     * @type {string}
     * @memberof KnowledgeBase
     */
    'id': string;
    /**
     * Name of the knowledge base
     * @type {string}
     * @memberof KnowledgeBase
     */
    'name': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof KnowledgeBase
     */
    'createdAt': string;
    /**
     * User who created the knowledge base
     * @type {string}
     * @memberof KnowledgeBase
     */
    'createdBy': string;
    /**
     * Size of the knowledge base in bytes
     * @type {number}
     * @memberof KnowledgeBase
     */
    'storageSizeBytes': number;
    /**
     * 
     * @type {KnowledgeBaseTestConfig}
     * @memberof KnowledgeBase
     */
    'defaultTestConfig'?: KnowledgeBaseTestConfig;
    /**
     * 
     * @type {Array<KnowledgeBaseSource>}
     * @memberof KnowledgeBase
     */
    'sources': Array<KnowledgeBaseSource>;
}
/**
 * 
 * @export
 * @interface KnowledgeBaseSource
 */
export interface KnowledgeBaseSource {
    /**
     * ID of the source
     * @type {string}
     * @memberof KnowledgeBaseSource
     */
    'id': string;
    /**
     * 
     * @type {KnowledgeBaseSourceData}
     * @memberof KnowledgeBaseSource
     */
    'data': KnowledgeBaseSourceData;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof KnowledgeBaseSource
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof KnowledgeBaseSource
     */
    'createdBy': string;
    /**
     * List of links crawled from the source link
     * @type {Array<KnowledgeBaseSourceDataCrawledLink>}
     * @memberof KnowledgeBaseSource
     */
    'crawledLinks'?: Array<KnowledgeBaseSourceDataCrawledLink>;
}
/**
 * @type KnowledgeBaseSourceData
 * @export
 */
export type KnowledgeBaseSourceData = KnowledgeBaseSourceDataFile | KnowledgeBaseSourceDataLink;

/**
 * 
 * @export
 * @interface KnowledgeBaseSourceDataCrawledLink
 */
export interface KnowledgeBaseSourceDataCrawledLink {
    /**
     * ID of the sublink
     * @type {string}
     * @memberof KnowledgeBaseSourceDataCrawledLink
     */
    'id': string;
    /**
     * URL of the sublink
     * @type {string}
     * @memberof KnowledgeBaseSourceDataCrawledLink
     */
    'url': string;
    /**
     * Title of the sublink
     * @type {string}
     * @memberof KnowledgeBaseSourceDataCrawledLink
     */
    'title': string;
    /**
     * Size of the knowledge base in bytes
     * @type {number}
     * @memberof KnowledgeBaseSourceDataCrawledLink
     */
    'storageSizeBytes': number;
    /**
     * MIME type of the file
     * @type {string}
     * @memberof KnowledgeBaseSourceDataCrawledLink
     */
    'mimetype': string;
    /**
     * ID of the parent link
     * @type {string}
     * @memberof KnowledgeBaseSourceDataCrawledLink
     */
    'parentLinkId'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof KnowledgeBaseSourceDataCrawledLink
     */
    'createdAt': string;
    /**
     * ID of the file
     * @type {string}
     * @memberof KnowledgeBaseSourceDataCrawledLink
     */
    'fileId': string;
}
/**
 * 
 * @export
 * @interface KnowledgeBaseSourceDataFile
 */
export interface KnowledgeBaseSourceDataFile {
    /**
     * URL of the uploaded file
     * @type {string}
     * @memberof KnowledgeBaseSourceDataFile
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof KnowledgeBaseSourceDataFile
     */
    'type': KnowledgeBaseSourceDataFileTypeEnum;
    /**
     * Size of the knowledge base in bytes
     * @type {number}
     * @memberof KnowledgeBaseSourceDataFile
     */
    'storageSizeBytes': number;
    /**
     * MIME type of the file
     * @type {string}
     * @memberof KnowledgeBaseSourceDataFile
     */
    'mimetype': string;
    /**
     * ID of the file
     * @type {string}
     * @memberof KnowledgeBaseSourceDataFile
     */
    'fileId': string;
    /**
     * 
     * @type {string}
     * @memberof KnowledgeBaseSourceDataFile
     */
    'filename'?: string;
}

export const KnowledgeBaseSourceDataFileTypeEnum = {
    File: 'file'
} as const;

export type KnowledgeBaseSourceDataFileTypeEnum = typeof KnowledgeBaseSourceDataFileTypeEnum[keyof typeof KnowledgeBaseSourceDataFileTypeEnum];

/**
 * 
 * @export
 * @interface KnowledgeBaseSourceDataLink
 */
export interface KnowledgeBaseSourceDataLink {
    /**
     * URL of the source link
     * @type {string}
     * @memberof KnowledgeBaseSourceDataLink
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof KnowledgeBaseSourceDataLink
     */
    'type': KnowledgeBaseSourceDataLinkTypeEnum;
    /**
     * Size of the knowledge base in bytes
     * @type {number}
     * @memberof KnowledgeBaseSourceDataLink
     */
    'storageSizeBytes': number;
    /**
     * 
     * @type {CrawlState}
     * @memberof KnowledgeBaseSourceDataLink
     */
    'state': CrawlState;
    /**
     * Maximum depth to scrape the link
     * @type {number}
     * @memberof KnowledgeBaseSourceDataLink
     */
    'maxDepth': number;
    /**
     * List of blocked links that should not be crawled
     * @type {Array<string>}
     * @memberof KnowledgeBaseSourceDataLink
     */
    'blockedLinks': Array<string>;
    /**
     * List of patterns that matched this link
     * @type {Array<string>}
     * @memberof KnowledgeBaseSourceDataLink
     */
    'patterns': Array<string>;
    /**
     * Interval in hours to refetch the link
     * @type {number}
     * @memberof KnowledgeBaseSourceDataLink
     */
    'refetchIntervalHours'?: number;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof KnowledgeBaseSourceDataLink
     */
    'nextFetchAt'?: string;
}

export const KnowledgeBaseSourceDataLinkTypeEnum = {
    Link: 'link'
} as const;

export type KnowledgeBaseSourceDataLinkTypeEnum = typeof KnowledgeBaseSourceDataLinkTypeEnum[keyof typeof KnowledgeBaseSourceDataLinkTypeEnum];

/**
 * 
 * @export
 * @interface KnowledgeBaseTestConfig
 */
export interface KnowledgeBaseTestConfig {
    /**
     * 
     * @type {LlmModel}
     * @memberof KnowledgeBaseTestConfig
     */
    'model'?: LlmModel;
    /**
     * Instructions to start the conversation
     * @type {string}
     * @memberof KnowledgeBaseTestConfig
     */
    'instructions'?: string;
}


/**
 * 
 * @export
 * @interface LlmChat200Response
 */
export interface LlmChat200Response {
    /**
     * 
     * @type {Array<LlmChatOutputItem>}
     * @memberof LlmChat200Response
     */
    'items': Array<LlmChatOutputItem>;
}
/**
 * @type LlmChatInput
 * @export
 */
export type LlmChatInput = CustomLlmChatInput | ImLlmChatInput;

/**
 * @type LlmChatOutputItem
 * @export
 */
export type LlmChatOutputItem = LlmChatOutputText | LlmChatOutputToolRequest;

/**
 * Text response from the chatbot
 * @export
 * @interface LlmChatOutputText
 */
export interface LlmChatOutputText {
    /**
     * 
     * @type {string}
     * @memberof LlmChatOutputText
     */
    'type': LlmChatOutputTextTypeEnum;
    /**
     * Text response from the chatbot
     * @type {string}
     * @memberof LlmChatOutputText
     */
    'text': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof LlmChatOutputText
     */
    'sources'?: Array<string>;
}

export const LlmChatOutputTextTypeEnum = {
    Text: 'text'
} as const;

export type LlmChatOutputTextTypeEnum = typeof LlmChatOutputTextTypeEnum[keyof typeof LlmChatOutputTextTypeEnum];

/**
 * Request execution of a tool
 * @export
 * @interface LlmChatOutputToolRequest
 */
export interface LlmChatOutputToolRequest {
    /**
     * 
     * @type {string}
     * @memberof LlmChatOutputToolRequest
     */
    'type': LlmChatOutputToolRequestTypeEnum;
    /**
     * Name of the tool to call
     * @type {string}
     * @memberof LlmChatOutputToolRequest
     */
    'name': string;
    /**
     * ID of the request
     * @type {string}
     * @memberof LlmChatOutputToolRequest
     */
    'id': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof LlmChatOutputToolRequest
     */
    'params': { [key: string]: any; };
}

export const LlmChatOutputToolRequestTypeEnum = {
    Tool: 'tool'
} as const;

export type LlmChatOutputToolRequestTypeEnum = typeof LlmChatOutputToolRequestTypeEnum[keyof typeof LlmChatOutputToolRequestTypeEnum];

/**
 * 
 * @export
 * @interface LlmChatRequest
 */
export interface LlmChatRequest {
    /**
     * Thread ID of the conversation
     * @type {string}
     * @memberof LlmChatRequest
     */
    'id': string;
    /**
     * 
     * @type {LlmChatInput}
     * @memberof LlmChatRequest
     */
    'input': LlmChatInput;
    /**
     * 
     * @type {Array<LlmTool>}
     * @memberof LlmChatRequest
     */
    'tools'?: Array<LlmTool>;
    /**
     * 
     * @type {LlmModel}
     * @memberof LlmChatRequest
     */
    'model'?: LlmModel;
    /**
     * 
     * @type {Array<string>}
     * @memberof LlmChatRequest
     */
    'knowledgeBaseIds'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof LlmChatRequest
     */
    'temperature'?: number;
    /**
     * Clear any existing conversation, and start a new one
     * @type {boolean}
     * @memberof LlmChatRequest
     */
    'clear'?: boolean;
}


/**
 * @type LlmMessage
 * @export
 */
export type LlmMessage = LlmMessageInput | LlmMessageToolOutput;

/**
 * 
 * @export
 * @interface LlmMessageInput
 */
export interface LlmMessageInput {
    /**
     * 
     * @type {string}
     * @memberof LlmMessageInput
     */
    'type': LlmMessageInputTypeEnum;
    /**
     * Text to send to the chatbot
     * @type {string}
     * @memberof LlmMessageInput
     */
    'text'?: string;
    /**
     * 
     * @type {string}
     * @memberof LlmMessageInput
     */
    'imageUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof LlmMessageInput
     */
    'fileUrl'?: string;
    /**
     * Role of the sender
     * @type {string}
     * @memberof LlmMessageInput
     */
    'role': LlmMessageInputRoleEnum;
}

export const LlmMessageInputTypeEnum = {
    Input: 'input'
} as const;

export type LlmMessageInputTypeEnum = typeof LlmMessageInputTypeEnum[keyof typeof LlmMessageInputTypeEnum];
export const LlmMessageInputRoleEnum = {
    User: 'user',
    System: 'system',
    Assistant: 'assistant'
} as const;

export type LlmMessageInputRoleEnum = typeof LlmMessageInputRoleEnum[keyof typeof LlmMessageInputRoleEnum];

/**
 * 
 * @export
 * @interface LlmMessageToolOutput
 */
export interface LlmMessageToolOutput {
    /**
     * 
     * @type {string}
     * @memberof LlmMessageToolOutput
     */
    'type': LlmMessageToolOutputTypeEnum;
    /**
     * ID of the tool call being responded to
     * @type {string}
     * @memberof LlmMessageToolOutput
     */
    'id': string;
    /**
     * Output of the tool
     * @type {string}
     * @memberof LlmMessageToolOutput
     */
    'output': string;
}

export const LlmMessageToolOutputTypeEnum = {
    ToolOutput: 'tool-output'
} as const;

export type LlmMessageToolOutputTypeEnum = typeof LlmMessageToolOutputTypeEnum[keyof typeof LlmMessageToolOutputTypeEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const LlmModel = {
    Gpt4oMini: 'gpt-4o-mini',
    Gpt4o: 'gpt-4o'
} as const;

export type LlmModel = typeof LlmModel[keyof typeof LlmModel];


/**
 * 
 * @export
 * @interface LlmTool
 */
export interface LlmTool {
    /**
     * Name of the tool, only supports alphanumeric characters
     * @type {string}
     * @memberof LlmTool
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof LlmTool
     */
    'description': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof LlmTool
     */
    'parameters': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface TranscribePost200Response
 */
export interface TranscribePost200Response {
    /**
     * 
     * @type {string}
     * @memberof TranscribePost200Response
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface TranscriptionJob
 */
export interface TranscriptionJob {
    /**
     * 
     * @type {string}
     * @memberof TranscriptionJob
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TranscriptionJob
     */
    'status': TranscriptionJobStatusEnum;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof TranscriptionJob
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof TranscriptionJob
     */
    'timesOutAt': string;
    /**
     * Transcription of the audio
     * @type {string}
     * @memberof TranscriptionJob
     */
    'transcription'?: string;
    /**
     * Error message if transcription failed
     * @type {string}
     * @memberof TranscriptionJob
     */
    'error'?: string;
}

export const TranscriptionJobStatusEnum = {
    Pending: 'pending',
    InProgress: 'in-progress',
    Completed: 'completed',
    Failed: 'failed'
} as const;

export type TranscriptionJobStatusEnum = typeof TranscriptionJobStatusEnum[keyof typeof TranscriptionJobStatusEnum];

/**
 * 
 * @export
 * @interface TranscriptionRequest
 */
export interface TranscriptionRequest {
    /**
     * 
     * @type {string}
     * @memberof TranscriptionRequest
     */
    'type': TranscriptionRequestTypeEnum;
    /**
     * The URL of the audio to transcribe
     * @type {string}
     * @memberof TranscriptionRequest
     */
    'url': string;
    /**
     * 
     * @type {AiCreditUseMetadata}
     * @memberof TranscriptionRequest
     */
    'metadata'?: AiCreditUseMetadata;
}

export const TranscriptionRequestTypeEnum = {
    Url: 'url'
} as const;

export type TranscriptionRequestTypeEnum = typeof TranscriptionRequestTypeEnum[keyof typeof TranscriptionRequestTypeEnum];

/**
 * 
 * @export
 * @interface UpsertKnowledgeBase
 */
export interface UpsertKnowledgeBase {
    /**
     * Name of the knowledge base
     * @type {string}
     * @memberof UpsertKnowledgeBase
     */
    'name'?: string;
    /**
     * 
     * @type {KnowledgeBaseTestConfig}
     * @memberof UpsertKnowledgeBase
     */
    'defaultTestConfig'?: KnowledgeBaseTestConfig;
}

/**
 * AudioTranscriptionApi - axios parameter creator
 * @export
 */
export const AudioTranscriptionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Polls the status of a transcription job
         * @summary Get the status of a transcription job
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transcribeGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('transcribeGet', 'id', id)
            const localVarPath = `/transcribe/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "token", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accepts an audio URL and converts it to text
         * @summary Convert audio URL to text
         * @param {TranscriptionRequest} transcriptionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transcribePost: async (transcriptionRequest: TranscriptionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transcriptionRequest' is not null or undefined
            assertParamExists('transcribePost', 'transcriptionRequest', transcriptionRequest)
            const localVarPath = `/transcribe`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "token", ["AUTOCOMPLETE_GET"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transcriptionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AudioTranscriptionApi - functional programming interface
 * @export
 */
export const AudioTranscriptionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AudioTranscriptionApiAxiosParamCreator(configuration)
    return {
        /**
         * Polls the status of a transcription job
         * @summary Get the status of a transcription job
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transcribeGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TranscriptionJob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transcribeGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AudioTranscriptionApi.transcribeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Accepts an audio URL and converts it to text
         * @summary Convert audio URL to text
         * @param {TranscriptionRequest} transcriptionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transcribePost(transcriptionRequest: TranscriptionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TranscribePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transcribePost(transcriptionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AudioTranscriptionApi.transcribePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AudioTranscriptionApi - factory interface
 * @export
 */
export const AudioTranscriptionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AudioTranscriptionApiFp(configuration)
    return {
        /**
         * Polls the status of a transcription job
         * @summary Get the status of a transcription job
         * @param {AudioTranscriptionApiTranscribeGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transcribeGet(requestParameters: AudioTranscriptionApiTranscribeGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<TranscriptionJob> {
            return localVarFp.transcribeGet(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Accepts an audio URL and converts it to text
         * @summary Convert audio URL to text
         * @param {AudioTranscriptionApiTranscribePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transcribePost(requestParameters: AudioTranscriptionApiTranscribePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<TranscribePost200Response> {
            return localVarFp.transcribePost(requestParameters.transcriptionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for transcribeGet operation in AudioTranscriptionApi.
 * @export
 * @interface AudioTranscriptionApiTranscribeGetRequest
 */
export interface AudioTranscriptionApiTranscribeGetRequest {
    /**
     * 
     * @type {string}
     * @memberof AudioTranscriptionApiTranscribeGet
     */
    readonly id: string
}

/**
 * Request parameters for transcribePost operation in AudioTranscriptionApi.
 * @export
 * @interface AudioTranscriptionApiTranscribePostRequest
 */
export interface AudioTranscriptionApiTranscribePostRequest {
    /**
     * 
     * @type {TranscriptionRequest}
     * @memberof AudioTranscriptionApiTranscribePost
     */
    readonly transcriptionRequest: TranscriptionRequest
}

/**
 * AudioTranscriptionApi - object-oriented interface
 * @export
 * @class AudioTranscriptionApi
 * @extends {BaseAPI}
 */
export class AudioTranscriptionApi extends BaseAPI {
    /**
     * Polls the status of a transcription job
     * @summary Get the status of a transcription job
     * @param {AudioTranscriptionApiTranscribeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudioTranscriptionApi
     */
    public transcribeGet(requestParameters: AudioTranscriptionApiTranscribeGetRequest, options?: RawAxiosRequestConfig) {
        return AudioTranscriptionApiFp(this.configuration).transcribeGet(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accepts an audio URL and converts it to text
     * @summary Convert audio URL to text
     * @param {AudioTranscriptionApiTranscribePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudioTranscriptionApi
     */
    public transcribePost(requestParameters: AudioTranscriptionApiTranscribePostRequest, options?: RawAxiosRequestConfig) {
        return AudioTranscriptionApiFp(this.configuration).transcribePost(requestParameters.transcriptionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AutocompleteApi - axios parameter creator
 * @export
 */
export const AutocompleteApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns autocomplete suggestions for a chat
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autocompleteInbox: async (accountId: string, chatId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('autocompleteInbox', 'accountId', accountId)
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('autocompleteInbox', 'chatId', chatId)
            const localVarPath = `/autocomplete/inbox/{accountId}/{chatId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"chatId"}}`, encodeURIComponent(String(chatId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "token", ["AUTOCOMPLETE_GET"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Apply some modification to the given text
         * @param {AutocompleteModifier} modifier 
         * @param {AutocompleteModifyRequest} autocompleteModifyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autocompleteModify: async (modifier: AutocompleteModifier, autocompleteModifyRequest: AutocompleteModifyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modifier' is not null or undefined
            assertParamExists('autocompleteModify', 'modifier', modifier)
            // verify required parameter 'autocompleteModifyRequest' is not null or undefined
            assertParamExists('autocompleteModify', 'autocompleteModifyRequest', autocompleteModifyRequest)
            const localVarPath = `/autocomplete/modify/{modifier}`
                .replace(`{${"modifier"}}`, encodeURIComponent(String(modifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "token", ["AUTOCOMPLETE_GET"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(autocompleteModifyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AutocompleteApi - functional programming interface
 * @export
 */
export const AutocompleteApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AutocompleteApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns autocomplete suggestions for a chat
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autocompleteInbox(accountId: string, chatId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutocompleteInbox200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autocompleteInbox(accountId, chatId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AutocompleteApi.autocompleteInbox']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Apply some modification to the given text
         * @param {AutocompleteModifier} modifier 
         * @param {AutocompleteModifyRequest} autocompleteModifyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autocompleteModify(modifier: AutocompleteModifier, autocompleteModifyRequest: AutocompleteModifyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutocompleteModify200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autocompleteModify(modifier, autocompleteModifyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AutocompleteApi.autocompleteModify']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AutocompleteApi - factory interface
 * @export
 */
export const AutocompleteApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AutocompleteApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns autocomplete suggestions for a chat
         * @param {AutocompleteApiAutocompleteInboxRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autocompleteInbox(requestParameters: AutocompleteApiAutocompleteInboxRequest, options?: RawAxiosRequestConfig): AxiosPromise<AutocompleteInbox200Response> {
            return localVarFp.autocompleteInbox(requestParameters.accountId, requestParameters.chatId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Apply some modification to the given text
         * @param {AutocompleteApiAutocompleteModifyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autocompleteModify(requestParameters: AutocompleteApiAutocompleteModifyRequest, options?: RawAxiosRequestConfig): AxiosPromise<AutocompleteModify200Response> {
            return localVarFp.autocompleteModify(requestParameters.modifier, requestParameters.autocompleteModifyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for autocompleteInbox operation in AutocompleteApi.
 * @export
 * @interface AutocompleteApiAutocompleteInboxRequest
 */
export interface AutocompleteApiAutocompleteInboxRequest {
    /**
     * 
     * @type {string}
     * @memberof AutocompleteApiAutocompleteInbox
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof AutocompleteApiAutocompleteInbox
     */
    readonly chatId: string
}

/**
 * Request parameters for autocompleteModify operation in AutocompleteApi.
 * @export
 * @interface AutocompleteApiAutocompleteModifyRequest
 */
export interface AutocompleteApiAutocompleteModifyRequest {
    /**
     * 
     * @type {AutocompleteModifier}
     * @memberof AutocompleteApiAutocompleteModify
     */
    readonly modifier: AutocompleteModifier

    /**
     * 
     * @type {AutocompleteModifyRequest}
     * @memberof AutocompleteApiAutocompleteModify
     */
    readonly autocompleteModifyRequest: AutocompleteModifyRequest
}

/**
 * AutocompleteApi - object-oriented interface
 * @export
 * @class AutocompleteApi
 * @extends {BaseAPI}
 */
export class AutocompleteApi extends BaseAPI {
    /**
     * 
     * @summary Returns autocomplete suggestions for a chat
     * @param {AutocompleteApiAutocompleteInboxRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutocompleteApi
     */
    public autocompleteInbox(requestParameters: AutocompleteApiAutocompleteInboxRequest, options?: RawAxiosRequestConfig) {
        return AutocompleteApiFp(this.configuration).autocompleteInbox(requestParameters.accountId, requestParameters.chatId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Apply some modification to the given text
     * @param {AutocompleteApiAutocompleteModifyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutocompleteApi
     */
    public autocompleteModify(requestParameters: AutocompleteApiAutocompleteModifyRequest, options?: RawAxiosRequestConfig) {
        return AutocompleteApiFp(this.configuration).autocompleteModify(requestParameters.modifier, requestParameters.autocompleteModifyRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ChatbotApi - axios parameter creator
 * @export
 */
export const ChatbotApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Send a message to an LLM
         * @param {LlmChatRequest} llmChatRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        llmChat: async (llmChatRequest: LlmChatRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'llmChatRequest' is not null or undefined
            assertParamExists('llmChat', 'llmChatRequest', llmChatRequest)
            const localVarPath = `/llm-chat`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "token", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(llmChatRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChatbotApi - functional programming interface
 * @export
 */
export const ChatbotApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChatbotApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Send a message to an LLM
         * @param {LlmChatRequest} llmChatRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async llmChat(llmChatRequest: LlmChatRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LlmChat200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.llmChat(llmChatRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatbotApi.llmChat']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ChatbotApi - factory interface
 * @export
 */
export const ChatbotApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChatbotApiFp(configuration)
    return {
        /**
         * 
         * @summary Send a message to an LLM
         * @param {ChatbotApiLlmChatRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        llmChat(requestParameters: ChatbotApiLlmChatRequest, options?: RawAxiosRequestConfig): AxiosPromise<LlmChat200Response> {
            return localVarFp.llmChat(requestParameters.llmChatRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for llmChat operation in ChatbotApi.
 * @export
 * @interface ChatbotApiLlmChatRequest
 */
export interface ChatbotApiLlmChatRequest {
    /**
     * 
     * @type {LlmChatRequest}
     * @memberof ChatbotApiLlmChat
     */
    readonly llmChatRequest: LlmChatRequest
}

/**
 * ChatbotApi - object-oriented interface
 * @export
 * @class ChatbotApi
 * @extends {BaseAPI}
 */
export class ChatbotApi extends BaseAPI {
    /**
     * 
     * @summary Send a message to an LLM
     * @param {ChatbotApiLlmChatRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatbotApi
     */
    public llmChat(requestParameters: ChatbotApiLlmChatRequest, options?: RawAxiosRequestConfig) {
        return ChatbotApiFp(this.configuration).llmChat(requestParameters.llmChatRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * KnowledgebaseApi - axios parameter creator
 * @export
 */
export const KnowledgebaseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a source to the knowledge base
         * @param {string} id 
         * @param {AddSourceRequest} addSourceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSource: async (id: string, addSourceRequest: AddSourceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addSource', 'id', id)
            // verify required parameter 'addSourceRequest' is not null or undefined
            assertParamExists('addSource', 'addSourceRequest', addSourceRequest)
            const localVarPath = `/knowledge-base/{id}/sources`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "token", ["AUTOCOMPLETE_GET"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addSourceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Crawl a source link
         * @param {string} id 
         * @param {string} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crawlSource: async (id: string, sourceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('crawlSource', 'id', id)
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('crawlSource', 'sourceId', sourceId)
            const localVarPath = `/knowledge-base/{id}/sources/{sourceId}/crawl`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a knowledge base
         * @param {UpsertKnowledgeBase} upsertKnowledgeBase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKnowledgeBase: async (upsertKnowledgeBase: UpsertKnowledgeBase, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'upsertKnowledgeBase' is not null or undefined
            assertParamExists('createKnowledgeBase', 'upsertKnowledgeBase', upsertKnowledgeBase)
            const localVarPath = `/knowledge-base`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "token", ["AUTOCOMPLETE_GET"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(upsertKnowledgeBase, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove & block a crawled link from a source
         * @param {string} baseId 
         * @param {string} sourceId 
         * @param {string} linkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCrawledLink: async (baseId: string, sourceId: string, linkId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'baseId' is not null or undefined
            assertParamExists('deleteCrawledLink', 'baseId', baseId)
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('deleteCrawledLink', 'sourceId', sourceId)
            // verify required parameter 'linkId' is not null or undefined
            assertParamExists('deleteCrawledLink', 'linkId', linkId)
            const localVarPath = `/knowledge-base/{baseId}/sources/{sourceId}/links/{linkId}`
                .replace(`{${"baseId"}}`, encodeURIComponent(String(baseId)))
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"linkId"}}`, encodeURIComponent(String(linkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a knowledge base
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKnowledgeBase: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteKnowledgeBase', 'id', id)
            const localVarPath = `/knowledge-base/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "token", ["AUTOCOMPLETE_GET"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a source from the knowledge base
         * @param {string} baseId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSource: async (baseId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'baseId' is not null or undefined
            assertParamExists('deleteSource', 'baseId', baseId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSource', 'id', id)
            const localVarPath = `/knowledge-base/{baseId}/sources/{id}`
                .replace(`{${"baseId"}}`, encodeURIComponent(String(baseId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "token", ["AUTOCOMPLETE_GET"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all links crawled from a source
         * @param {string} baseId 
         * @param {string} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrawledLinks: async (baseId: string, sourceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'baseId' is not null or undefined
            assertParamExists('getCrawledLinks', 'baseId', baseId)
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getCrawledLinks', 'sourceId', sourceId)
            const localVarPath = `/knowledge-base/{baseId}/sources/{sourceId}/links`
                .replace(`{${"baseId"}}`, encodeURIComponent(String(baseId)))
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all knowledge bases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKnowledgeBases: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/knowledge-base`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "token", ["AUTOCOMPLETE_GET"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all sources in a knowledge base
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSources: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSources', 'id', id)
            const localVarPath = `/knowledge-base/{id}/sources`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "token", ["AUTOCOMPLETE_GET"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the name of a knowledge base
         * @param {string} id 
         * @param {UpsertKnowledgeBase} upsertKnowledgeBase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKnowledgeBase: async (id: string, upsertKnowledgeBase: UpsertKnowledgeBase, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateKnowledgeBase', 'id', id)
            // verify required parameter 'upsertKnowledgeBase' is not null or undefined
            assertParamExists('updateKnowledgeBase', 'upsertKnowledgeBase', upsertKnowledgeBase)
            const localVarPath = `/knowledge-base/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "token", ["AUTOCOMPLETE_GET"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(upsertKnowledgeBase, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KnowledgebaseApi - functional programming interface
 * @export
 */
export const KnowledgebaseApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = KnowledgebaseApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a source to the knowledge base
         * @param {string} id 
         * @param {AddSourceRequest} addSourceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addSource(id: string, addSourceRequest: AddSourceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KnowledgeBaseSource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addSource(id, addSourceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KnowledgebaseApi.addSource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Crawl a source link
         * @param {string} id 
         * @param {string} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crawlSource(id: string, sourceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KnowledgeBaseSource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crawlSource(id, sourceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KnowledgebaseApi.crawlSource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a knowledge base
         * @param {UpsertKnowledgeBase} upsertKnowledgeBase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createKnowledgeBase(upsertKnowledgeBase: UpsertKnowledgeBase, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KnowledgeBase>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createKnowledgeBase(upsertKnowledgeBase, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KnowledgebaseApi.createKnowledgeBase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove & block a crawled link from a source
         * @param {string} baseId 
         * @param {string} sourceId 
         * @param {string} linkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCrawledLink(baseId: string, sourceId: string, linkId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCrawledLink(baseId, sourceId, linkId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KnowledgebaseApi.deleteCrawledLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a knowledge base
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteKnowledgeBase(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteKnowledgeBase(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KnowledgebaseApi.deleteKnowledgeBase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a source from the knowledge base
         * @param {string} baseId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSource(baseId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSource(baseId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KnowledgebaseApi.deleteSource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all links crawled from a source
         * @param {string} baseId 
         * @param {string} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCrawledLinks(baseId: string, sourceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCrawledLinks200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCrawledLinks(baseId, sourceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KnowledgebaseApi.getCrawledLinks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all knowledge bases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKnowledgeBases(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetKnowledgeBases200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKnowledgeBases(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KnowledgebaseApi.getKnowledgeBases']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all sources in a knowledge base
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSources(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSources200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSources(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KnowledgebaseApi.getSources']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the name of a knowledge base
         * @param {string} id 
         * @param {UpsertKnowledgeBase} upsertKnowledgeBase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateKnowledgeBase(id: string, upsertKnowledgeBase: UpsertKnowledgeBase, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateKnowledgeBase(id, upsertKnowledgeBase, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KnowledgebaseApi.updateKnowledgeBase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * KnowledgebaseApi - factory interface
 * @export
 */
export const KnowledgebaseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = KnowledgebaseApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a source to the knowledge base
         * @param {KnowledgebaseApiAddSourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSource(requestParameters: KnowledgebaseApiAddSourceRequest, options?: RawAxiosRequestConfig): AxiosPromise<KnowledgeBaseSource> {
            return localVarFp.addSource(requestParameters.id, requestParameters.addSourceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Crawl a source link
         * @param {KnowledgebaseApiCrawlSourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crawlSource(requestParameters: KnowledgebaseApiCrawlSourceRequest, options?: RawAxiosRequestConfig): AxiosPromise<KnowledgeBaseSource> {
            return localVarFp.crawlSource(requestParameters.id, requestParameters.sourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a knowledge base
         * @param {KnowledgebaseApiCreateKnowledgeBaseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKnowledgeBase(requestParameters: KnowledgebaseApiCreateKnowledgeBaseRequest, options?: RawAxiosRequestConfig): AxiosPromise<KnowledgeBase> {
            return localVarFp.createKnowledgeBase(requestParameters.upsertKnowledgeBase, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove & block a crawled link from a source
         * @param {KnowledgebaseApiDeleteCrawledLinkRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCrawledLink(requestParameters: KnowledgebaseApiDeleteCrawledLinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteCrawledLink(requestParameters.baseId, requestParameters.sourceId, requestParameters.linkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a knowledge base
         * @param {KnowledgebaseApiDeleteKnowledgeBaseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKnowledgeBase(requestParameters: KnowledgebaseApiDeleteKnowledgeBaseRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteKnowledgeBase(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a source from the knowledge base
         * @param {KnowledgebaseApiDeleteSourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSource(requestParameters: KnowledgebaseApiDeleteSourceRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSource(requestParameters.baseId, requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all links crawled from a source
         * @param {KnowledgebaseApiGetCrawledLinksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrawledLinks(requestParameters: KnowledgebaseApiGetCrawledLinksRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetCrawledLinks200Response> {
            return localVarFp.getCrawledLinks(requestParameters.baseId, requestParameters.sourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all knowledge bases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKnowledgeBases(options?: RawAxiosRequestConfig): AxiosPromise<GetKnowledgeBases200Response> {
            return localVarFp.getKnowledgeBases(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all sources in a knowledge base
         * @param {KnowledgebaseApiGetSourcesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSources(requestParameters: KnowledgebaseApiGetSourcesRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetSources200Response> {
            return localVarFp.getSources(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the name of a knowledge base
         * @param {KnowledgebaseApiUpdateKnowledgeBaseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKnowledgeBase(requestParameters: KnowledgebaseApiUpdateKnowledgeBaseRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateKnowledgeBase(requestParameters.id, requestParameters.upsertKnowledgeBase, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addSource operation in KnowledgebaseApi.
 * @export
 * @interface KnowledgebaseApiAddSourceRequest
 */
export interface KnowledgebaseApiAddSourceRequest {
    /**
     * 
     * @type {string}
     * @memberof KnowledgebaseApiAddSource
     */
    readonly id: string

    /**
     * 
     * @type {AddSourceRequest}
     * @memberof KnowledgebaseApiAddSource
     */
    readonly addSourceRequest: AddSourceRequest
}

/**
 * Request parameters for crawlSource operation in KnowledgebaseApi.
 * @export
 * @interface KnowledgebaseApiCrawlSourceRequest
 */
export interface KnowledgebaseApiCrawlSourceRequest {
    /**
     * 
     * @type {string}
     * @memberof KnowledgebaseApiCrawlSource
     */
    readonly id: string

    /**
     * 
     * @type {string}
     * @memberof KnowledgebaseApiCrawlSource
     */
    readonly sourceId: string
}

/**
 * Request parameters for createKnowledgeBase operation in KnowledgebaseApi.
 * @export
 * @interface KnowledgebaseApiCreateKnowledgeBaseRequest
 */
export interface KnowledgebaseApiCreateKnowledgeBaseRequest {
    /**
     * 
     * @type {UpsertKnowledgeBase}
     * @memberof KnowledgebaseApiCreateKnowledgeBase
     */
    readonly upsertKnowledgeBase: UpsertKnowledgeBase
}

/**
 * Request parameters for deleteCrawledLink operation in KnowledgebaseApi.
 * @export
 * @interface KnowledgebaseApiDeleteCrawledLinkRequest
 */
export interface KnowledgebaseApiDeleteCrawledLinkRequest {
    /**
     * 
     * @type {string}
     * @memberof KnowledgebaseApiDeleteCrawledLink
     */
    readonly baseId: string

    /**
     * 
     * @type {string}
     * @memberof KnowledgebaseApiDeleteCrawledLink
     */
    readonly sourceId: string

    /**
     * 
     * @type {string}
     * @memberof KnowledgebaseApiDeleteCrawledLink
     */
    readonly linkId: string
}

/**
 * Request parameters for deleteKnowledgeBase operation in KnowledgebaseApi.
 * @export
 * @interface KnowledgebaseApiDeleteKnowledgeBaseRequest
 */
export interface KnowledgebaseApiDeleteKnowledgeBaseRequest {
    /**
     * 
     * @type {string}
     * @memberof KnowledgebaseApiDeleteKnowledgeBase
     */
    readonly id: string
}

/**
 * Request parameters for deleteSource operation in KnowledgebaseApi.
 * @export
 * @interface KnowledgebaseApiDeleteSourceRequest
 */
export interface KnowledgebaseApiDeleteSourceRequest {
    /**
     * 
     * @type {string}
     * @memberof KnowledgebaseApiDeleteSource
     */
    readonly baseId: string

    /**
     * 
     * @type {string}
     * @memberof KnowledgebaseApiDeleteSource
     */
    readonly id: string
}

/**
 * Request parameters for getCrawledLinks operation in KnowledgebaseApi.
 * @export
 * @interface KnowledgebaseApiGetCrawledLinksRequest
 */
export interface KnowledgebaseApiGetCrawledLinksRequest {
    /**
     * 
     * @type {string}
     * @memberof KnowledgebaseApiGetCrawledLinks
     */
    readonly baseId: string

    /**
     * 
     * @type {string}
     * @memberof KnowledgebaseApiGetCrawledLinks
     */
    readonly sourceId: string
}

/**
 * Request parameters for getSources operation in KnowledgebaseApi.
 * @export
 * @interface KnowledgebaseApiGetSourcesRequest
 */
export interface KnowledgebaseApiGetSourcesRequest {
    /**
     * 
     * @type {string}
     * @memberof KnowledgebaseApiGetSources
     */
    readonly id: string
}

/**
 * Request parameters for updateKnowledgeBase operation in KnowledgebaseApi.
 * @export
 * @interface KnowledgebaseApiUpdateKnowledgeBaseRequest
 */
export interface KnowledgebaseApiUpdateKnowledgeBaseRequest {
    /**
     * 
     * @type {string}
     * @memberof KnowledgebaseApiUpdateKnowledgeBase
     */
    readonly id: string

    /**
     * 
     * @type {UpsertKnowledgeBase}
     * @memberof KnowledgebaseApiUpdateKnowledgeBase
     */
    readonly upsertKnowledgeBase: UpsertKnowledgeBase
}

/**
 * KnowledgebaseApi - object-oriented interface
 * @export
 * @class KnowledgebaseApi
 * @extends {BaseAPI}
 */
export class KnowledgebaseApi extends BaseAPI {
    /**
     * 
     * @summary Add a source to the knowledge base
     * @param {KnowledgebaseApiAddSourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgebaseApi
     */
    public addSource(requestParameters: KnowledgebaseApiAddSourceRequest, options?: RawAxiosRequestConfig) {
        return KnowledgebaseApiFp(this.configuration).addSource(requestParameters.id, requestParameters.addSourceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Crawl a source link
     * @param {KnowledgebaseApiCrawlSourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgebaseApi
     */
    public crawlSource(requestParameters: KnowledgebaseApiCrawlSourceRequest, options?: RawAxiosRequestConfig) {
        return KnowledgebaseApiFp(this.configuration).crawlSource(requestParameters.id, requestParameters.sourceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a knowledge base
     * @param {KnowledgebaseApiCreateKnowledgeBaseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgebaseApi
     */
    public createKnowledgeBase(requestParameters: KnowledgebaseApiCreateKnowledgeBaseRequest, options?: RawAxiosRequestConfig) {
        return KnowledgebaseApiFp(this.configuration).createKnowledgeBase(requestParameters.upsertKnowledgeBase, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove & block a crawled link from a source
     * @param {KnowledgebaseApiDeleteCrawledLinkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgebaseApi
     */
    public deleteCrawledLink(requestParameters: KnowledgebaseApiDeleteCrawledLinkRequest, options?: RawAxiosRequestConfig) {
        return KnowledgebaseApiFp(this.configuration).deleteCrawledLink(requestParameters.baseId, requestParameters.sourceId, requestParameters.linkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a knowledge base
     * @param {KnowledgebaseApiDeleteKnowledgeBaseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgebaseApi
     */
    public deleteKnowledgeBase(requestParameters: KnowledgebaseApiDeleteKnowledgeBaseRequest, options?: RawAxiosRequestConfig) {
        return KnowledgebaseApiFp(this.configuration).deleteKnowledgeBase(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a source from the knowledge base
     * @param {KnowledgebaseApiDeleteSourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgebaseApi
     */
    public deleteSource(requestParameters: KnowledgebaseApiDeleteSourceRequest, options?: RawAxiosRequestConfig) {
        return KnowledgebaseApiFp(this.configuration).deleteSource(requestParameters.baseId, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all links crawled from a source
     * @param {KnowledgebaseApiGetCrawledLinksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgebaseApi
     */
    public getCrawledLinks(requestParameters: KnowledgebaseApiGetCrawledLinksRequest, options?: RawAxiosRequestConfig) {
        return KnowledgebaseApiFp(this.configuration).getCrawledLinks(requestParameters.baseId, requestParameters.sourceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all knowledge bases
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgebaseApi
     */
    public getKnowledgeBases(options?: RawAxiosRequestConfig) {
        return KnowledgebaseApiFp(this.configuration).getKnowledgeBases(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all sources in a knowledge base
     * @param {KnowledgebaseApiGetSourcesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgebaseApi
     */
    public getSources(requestParameters: KnowledgebaseApiGetSourcesRequest, options?: RawAxiosRequestConfig) {
        return KnowledgebaseApiFp(this.configuration).getSources(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the name of a knowledge base
     * @param {KnowledgebaseApiUpdateKnowledgeBaseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgebaseApi
     */
    public updateKnowledgeBase(requestParameters: KnowledgebaseApiUpdateKnowledgeBaseRequest, options?: RawAxiosRequestConfig) {
        return KnowledgebaseApiFp(this.configuration).updateKnowledgeBase(requestParameters.id, requestParameters.upsertKnowledgeBase, options).then((request) => request(this.axios, this.basePath));
    }
}



